package org.onebusaway.realtime.hamilton.services;

import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.TimeUnit;

import org.apache.commons.io.IOUtils;
import org.codehaus.jackson.JsonNode;
import org.codehaus.jackson.map.AnnotationIntrospector;
import org.codehaus.jackson.map.ObjectMapper;
import org.codehaus.jackson.xc.JaxbAnnotationIntrospector;
import org.onebusaway.realtime.hamilton.model.IRecordFactory;
import org.onebusaway.realtime.hamilton.model.IRecord;
import org.onebusaway.realtime.hamilton.model.PositionReport;
import org.onebusaway.realtime.hamilton.model.PositionReportRecordFactory;
import org.onebusaway.realtime.hamilton.model.VehicleMessage;
import org.onebusaway.realtime.hamilton.model.VehicleRecord;
import org.onebusaway.realtime.hamilton.model.WayfarerLogonRecordFactory;
import org.onebusaway.realtime.hamilton.tds.AVLTranslator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;

public class VehicleUpdateServiceImpl implements VehicleUpdateService {

  private static final Logger _log = LoggerFactory.getLogger(VehicleUpdateServiceImpl.class);

  private static final String TCIP_KEY = "tcip";

  private static final String UPDATE_MESSAGE_MARKER = "RTCP";
  private static final String LOGON_MESSAGE_MARKER = "\u0002\u0051\u001c";
  private static final String LOGOFF_MESSAGE_MARKER = "\u0002\u0051\u0003";
  
  protected ObjectMapper _mapper = new ObjectMapper();
  
  private Cache<String, VehicleMessage> _cache;
  private Cache<String, VehicleRecord> _vrCache;

  private int _timeout = 5; // minutes
  
  static Map<String, IRecordFactory<?>> recordFactories;

  private AVLTranslator _avlTranslator = null;
  public void setAVLTranslator(AVLTranslator avl) {
    _avlTranslator = avl;
  }
  
  
  static {
    recordFactories = new HashMap<String, IRecordFactory<?>>();
    recordFactories.put(UPDATE_MESSAGE_MARKER, new PositionReportRecordFactory());
    recordFactories.put(LOGON_MESSAGE_MARKER, new WayfarerLogonRecordFactory());
    
  }
  
  public VehicleUpdateServiceImpl() {
    /*
     * Use JAXB annotation interceptor so we pick up autogenerated annotations
     * from XSDs
     */
    final AnnotationIntrospector jaxb = new JaxbAnnotationIntrospector();
    _mapper.getDeserializationConfig().setAnnotationIntrospector(jaxb);
    _cache = CacheBuilder.newBuilder().expireAfterWrite(_timeout, TimeUnit.MINUTES).build();
    _vrCache = CacheBuilder.newBuilder().expireAfterWrite(_timeout, TimeUnit.MINUTES).build();
  }
  
  
  public boolean dispatch(InputStream inputStream) throws Exception {
    // look at the next few bytes
    inputStream.mark(4);

    // if bytemarker then go to gps update
    int stx = inputStream.read();
    int byteMarker = inputStream.read();
    int size = inputStream.read();
    int trail = inputStream.read();
    byte[] muxArray = {(byte) stx, (byte) byteMarker, (byte) size, (byte) trail};
    inputStream.reset();
    _log.debug("dispatch byteMarker=" + byteMarker);
    // check if logon
    if (byteMarker == 81) {
      _log.info("size=" + size);
      if (size == 3) {
        _log.debug("found logoff");
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        byte buff[] = new byte[6]; 
        IOUtils.read(inputStream, buff, 0, 6);
        this.receiveWayfarerLogOnOff(buff);
        return true;
      } else if (size >= 27) {
        _log.debug("found logon");
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        byte buff[] = new byte[size + 3]; 
        IOUtils.read(inputStream, buff, 0, size + 3);
        this.receiveWayfarerLogOnOff(buff);
        return true;
      } else {
        _log.info("unexpected size=" + size);
        inputStream.read();
        return false;
      }
    } else {
      _log.debug("possible gps update");
      // GPS Update message?
      String mux = new String(muxArray);
      if ("RTCP".equals(mux)) {
        _log.debug("RTCP found!");
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        byte buff[] = new byte[135]; 
        IOUtils.read(inputStream, buff, 0, 135);
        PositionReport record = (PositionReport) recieveGPSUpdate(buff);
        _log.info(record.toString());
//        _log.error("found [" + record.getId() + "] operator " + record.getOperatorId()
//            + " driverId " + record.getDriverId()
//            + " at " + record.getLat() + ", " + record.getLon() 
//            + " travelling at "  + record.getSpeed());
        addPositionReport(record);
        return true;
      } else {
        _log.debug("unexpected mux=" + mux + ":" 
      + "\\x" + Integer.toHexString(stx)
      + "\\x" + Integer.toHexString(byteMarker)
      + "\\x" + Integer.toHexString(size)
      + "\\x" + Integer.toHexString(trail)
      + "(" +stx+byteMarker+size+trail+")"
      + "(" 
      + bcdToString((byte)stx) 
      + bcdToString((byte)byteMarker)
      + bcdToString((byte)size)
      + bcdToString((byte)trail)
      + ")"
      );
        inputStream.read();
        return false;
      }
    }
  }

  
  private void addPositionReport(PositionReport pr) {
    VehicleRecord vr = _avlTranslator.translate(pr);
    if (vr == null) return;
    _vrCache.put(vr.getVehicleId(), vr);
  }


  public void receiveTCIP(byte[] buff) {
    VehicleMessage vm = null;
    try {
      final JsonNode message = _mapper.readValue(buff, JsonNode.class);
      final String vehicleMessageStr = message.get(TCIP_KEY).toString();
      vm = _mapper.readValue(vehicleMessageStr, VehicleMessage.class);
      if (vm != null) {
        put(vm);
      }
    } catch (Exception e) {
      _log.error("unexpected message=" + buff, e);
    }
  }

  private void put(VehicleMessage vm) {
    if (vm.getId() != null) {
      _cache.put(vm.getId(), vm);
    }
  }

  public List<VehicleMessage> getRecentMessages() {
    List<VehicleMessage> vehicles = new ArrayList<VehicleMessage>();
    Map<String,VehicleMessage> map = _cache.asMap();
    for (Entry<String, VehicleMessage> vm: map.entrySet()) {
      vehicles.add(vm.getValue());
    }
    return vehicles;
  }
  
  public List<VehicleRecord> getRecentVehicleRecords() {
    List<VehicleRecord> vehicles = new ArrayList<VehicleRecord>();
    Map<String, VehicleRecord> map = _vrCache.asMap();
    for (Entry<String, VehicleRecord> vr: map.entrySet()) {
      vehicles.add(vr.getValue());
    }
    return vehicles;
  }


  public IRecord receiveWayfarerLogOnOff(byte[] buff) {
    if (buff.length >= 27) {
      int start = 0;
      int len = buff.length;
      _log.info("u(" + len + "):" + new String(buff));
      
      String byteMarker = new String(Arrays.copyOfRange(buff, 0, 3));
      _log.info("byteMarker=" + byteMarker);
      IRecordFactory<?> factory = recordFactories.get(byteMarker);
      if (factory != null) {
         return factory.createRecord(buff, 0, buff.length);
      } else {
        _log.error("missing factory for record type=" + byteMarker + ", discarded " + new String(buff));
      }
    } else if (buff.length == 6) {
      String cmd = bcdToString(buff, 3, 1);
      _log.info("logoff=" + cmd);
    } else {
      _log.error("unexpected size of buffer=" + buff.length);
    }
    return null;
  }

  private String bcdToString(byte[] buff, int start, int length) {
    StringBuffer sb = new StringBuffer();
    
    for (int i = start; i < start+length; i++) {
      sb.append(bcdToString(buff[i]));
    }
    return sb.toString();
  }

  public String bcdToString(byte bcd) {
    StringBuffer sb = new StringBuffer();
    byte high = (byte) (bcd & 0xf0);
    high >>>= (byte) 4; 
    high = (byte) (high & 0x0f);
    byte low = (byte) (bcd & 0x0f);
    sb.append(high);
    sb.append(low);
    return sb.toString();
  }
  
  private int getBytesAsInteger(byte[] buff, int i, int j) {
    return Integer.valueOf(getBytesAsString(buff, i, j));
  }

  private byte[] getBytes(byte[] buff, int i, int j) {
    return Arrays.copyOfRange(buff, i, i+j);
  }

  private char getByteAsChar(byte[] buff, int i) {
    int aChar = (int)buff[i];
    aChar+=32;
    return (char)aChar;
  }

  private String getBytesAsString(byte[] buff, int i, int j) {
    
    return new String(Arrays.copyOfRange(buff, i, i+j));
  }

  /**
   * GPS Update.
   * 
   */
  public IRecord recieveGPSUpdate(byte[] buff) {
    int start = 0;
    int len = buff.length;
    _log.info("u(" + len + "):" + new String(buff));
    
    if (len > 4 ) {
      String byteMarker = new String(Arrays.copyOfRange(buff, 0, 4));
//      _log.info("byteMarker=" + byteMarker);
      if (UPDATE_MESSAGE_MARKER.equals(byteMarker)) {
        IRecordFactory<?> factory = recordFactories.get(byteMarker);
        if (factory != null) {
         return  factory.createRecord(buff, 0, buff.length);
        } else {
          _log.error("missing factory for record type=" + byteMarker + ", discarded " + new String(buff));
        }
      }
      
    } else {
//      _log.info("discarded=" + bcdToString(buffer.toByteArray(), 0, len) + "(" + len + ")");
    }
    return null;
  }

}
